# -*- coding: utf-8 -*-
"""PronoZarate-AtuchaCampanaEscobar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hJ14_FZtkdYGB2Jhx0oRFvvEcyXMhOTm

Carga librerias
"""

import requests, psycopg2
import pandas as pd
import numpy as np
from datetime import timedelta,datetime
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates
from matplotlib.dates import DateFormatter
import json
from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score

# carga credenciales de API
with open("apiLoginParams.json") as f:
	apiLoginParams = json.load(f)

### FUNCIONES ###

def outputcsv(df,outputfile):
    csvoutput = open(outputfile,"w")
    csvoutput.write(df.to_csv())
    csvoutput.close()

def prono2serie(df,main_colname="h_sim",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=3398):
    df_simulado = df.copy().reset_index()
    # df_simulado['fecha'] = df_simulado['fecha'].dt.tz_localize("America/Argentina/Buenos_Aires") # timezone.localize(df_simulado['fecha'])
    column_mapper = {
        'fecha': 'timestart'
    }
    column_mapper[main_colname] = 'valor'
    df_para_upsert = df_simulado[['fecha',main_colname]].rename(axis=1, mapper=column_mapper,inplace = False)
    # print(df_para_upsert)
    df_para_upsert['qualifier'] = 'main'
    for member in members:
        column_mapper = { 'fecha': 'timestart'}
        column_mapper[member] = "valor"
        df_para_upsert = df_para_upsert.append(df_simulado[['fecha',member]].rename(axis=1, mapper=column_mapper), ignore_index=True)
        df_para_upsert['qualifier'].fillna(value=members[member],inplace=True)
    df_para_upsert['timeend'] = df_para_upsert['timestart']  # .map(lambda a : a.isoformat())
    return {
                'series_table': 'series',
                'series_id': series_id,
                'pronosticos': json.loads(df_para_upsert.to_json(orient='records',date_format='iso'))
           }

def prono2json(series,forecast_date=datetime.now()):
    return {
        'forecast_date': forecast_date.isoformat(), #.tz_localize("America/Argentina/Buenos_Aires").isoformat(), # df_Sim['fecha_emision'].max().isoformat(),
        'series': series
    }

def outputjson(data,outputfile):
    output = open(outputfile,'w')
    output.write(json.dumps(data))
    output.close()

def uploadProno(data,cal_id,responseOutputFile):
    response = requests.post(
        apiLoginParams["url"] + '/sim/calibrados/' + str(cal_id) + '/corridas',
        data=json.dumps(data),
        headers={'Authorization': 'Bearer ' + apiLoginParams["token"], 'Content-type': 'application/json'},
    )
    print("prono upload, response code: " + str(response.status_code))
    print("prono upload, reason: " + response.reason)
    if(response.status_code == 200):
        if(responseOutputFile):
            outresponse = open(responseOutputFile,"w")
            outresponse.write(json.dumps(response.json()))
            outresponse.close()

def uploadPronoSeries(series,cal_id=440,forecast_date=datetime.now(),outputfile=None,responseOutputFile=None):
    data = prono2json(series,forecast_date)
    if(outputfile):
        outputjson(data,outputfile)
        uploadProno(data,cal_id,responseOutputFile)


def getLastProno(cal_id=288,filter={}):
    response = requests.get(
        apiLoginParams["url"] + '/sim/calibrados/' + str(cal_id) + '/corridas/last',
        params = filter,
        headers = {'Authorization': 'Bearer ' + apiLoginParams["token"]},
    )
    json_response = response.json()
    df_sim = pd.DataFrame.from_dict(json_response['series'][0]['pronosticos'],orient='columns')
    df_sim = df_sim.rename(columns={0:'fecha',1:'fecha2',2:'h_sim',3:'main'})
    df_sim = df_sim[['fecha','h_sim']]
    df_sim['fecha'] = pd.to_datetime(df_sim['fecha'])
    df_sim['h_sim'] = df_sim['h_sim'].astype(float)
    df_sim = df_sim.sort_values(by='fecha')
    df_sim.set_index(df_sim['fecha'], inplace=True)
    # df_sim.index = df_sim.index.tz_convert(None)
    del df_sim['fecha']
    return df_sim

def getObs(series_id,timestart,timeend):
    response = requests.get(
        apiLoginParams["url"] + '/obs/puntual/observaciones',
        params={
            'series_id': series_id,
            'timestart': timestart,
            'timeend': timeend
        },
        headers={'Authorization': 'Bearer ' + apiLoginParams["token"]},
    )
    json_response = response.json()
    df_obs = pd.DataFrame.from_dict(json_response)
    df_obs = df_obs.rename(columns={'timestart':'fecha','valor':'h_obs'})
    df_obs = df_obs[['fecha','h_obs']]
    df_obs['fecha'] = pd.to_datetime(df_obs['fecha']).dt.round('min')            # Fecha a formato fecha -- CAMBIADO PARA QUE CORRA EN PYTHON 3.5
    df_obs['h_obs'] = df_obs['h_obs'].astype(float)
    df_obs['fecha'] = pd.to_datetime(df_obs['fecha']).dt.round('min')            # Fecha a formato fecha
    df_obs.set_index(df_obs['fecha'], inplace=True)
    del df_obs['fecha']
    return df_obs

def eliminaSaltos(df,umbral):
    df['dif_F'] = df['h_obs'].diff(periods=1).abs()
    df['dif_B'] = df['h_obs'].diff(periods=-1).abs()
    df = df.fillna(0)
    df = df[(df['dif_F']<umbral) & (df['dif_B']<umbral)]
    return df

def plotObsVsSim(df):
    fig = plt.figure(figsize=(17, 8))
    ax = fig.add_subplot(1, 1, 1)
    ax.plot(df.index, df['h_obs'], 'b-',label='Observado')
    ax.plot(df.index, df['h_sim'], 'r-',label='Simulado')
    plt.grid(True, which='both', color='0.75', linestyle='-.', linewidth=0.5)
    plt.tick_params(axis='both', labelsize=18)
    plt.xlabel('Fecha', size=18)
    plt.ylabel('Nivel [m]', size=18)
    plt.legend(prop={'size':20},loc=0)
    plt.tight_layout()
    plt.show()

def plotObsVsSimVsPred(df,train):
        fig = plt.figure(figsize=(17, 8))
        ax = fig.add_subplot(1, 1, 1)
        ax.plot(df.index, df['h_sim'], 'b-',label='Simulado')
        ax.plot(df.index, df['h_obs'], 'r-',label='Observado')
        ax.plot(train.index, train['Y_predictions'], 'k-',label='Ajuste RL')
        plt.grid(True, which='both', color='0.75', linestyle='-.', linewidth=0.5)
        plt.tick_params(axis='both', labelsize=18)
        plt.xlabel('Fecha', size=18)
        plt.ylabel('Nivel [m]', size=18)
        plt.legend(prop={'size':20},loc=0)
        plt.tight_layout()
        plt.show()

def plotFinal(df_obs,df_sim,nameout='productos/plot_final.png',ydisplay=1,xytext=(-480,-250),ylim=(-1,2.5),markersize=None,text_xoffset=(-4,-8),obs_label='Nivel Observado',extraObs=None,extraObsLabel='Nivel Observado 2', fecha_emision = None, bandaDeError=('e_pred_01','e_pred_99'),obsLine=True):

    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(1, 1, 1)

    ax.plot(df_sim.index, df_sim['Y_predic'], '-',color='b',label='Nivel Pronosticado',linewidth=3)
    if not isinstance(df_obs, type(None)):
        ax.plot(df_obs.index, df_obs['h_obs'],'o',color='k',label=obs_label,linewidth=3)
        if obsLine:
            ax.plot(df_obs.index, df_obs['h_obs'],'-',color='k',linewidth=1,markersize=markersize)

    if not isinstance(extraObs,type(None)):
        ax.plot(extraObs.index, extraObs['h_obs'],'o',color='grey',label=extraObsLabel,linewidth=3,alpha=0.5)
        ax.plot(extraObs.index, extraObs['h_obs'],'-',color='grey',linewidth=1,alpha=0.5)

    ax.plot(df_sim.index, df_sim[bandaDeError[0]],'-',color='k',linewidth=0.5,alpha=0.75)
    ax.plot(df_sim.index, df_sim[bandaDeError[1]],'-',color='k',linewidth=0.5,alpha=0.75)
    ax.fill_between(df_sim.index,df_sim[bandaDeError[0]], df_sim[bandaDeError[1]],alpha=0.1,label='Banda de error')

    # Lineas: 1 , 1.5 y 2 mts
    xmin=df_sim.index.min()
    xmax=df_sim.index.max()

    # En cero escala Paranacito Prefectura
    #plt.hlines(5, xmin, xmax, colors='r', linestyles='-.', label='Evacuación',linewidth=1.5)
    #plt.hlines(2.3, xmin, xmax, colors='y', linestyles='-.', label='Alerta',linewidth=1.5)
    #plt.hlines(1.1, xmin, xmax, colors='y', linestyles='-.', label='Aguas Bajas',linewidth=1.5)

    # fecha emision
    if fecha_emision:
        ahora = fecha_emision
    elif not isinstance(df_obs, type(None)):
        ahora = df_obs.index.max()
    else: 
        ahora = datetime.now()
    
    plt.axvline(x=ahora,color="black", linestyle="--",linewidth=2)#,label='Fecha de emisión')

    bbox = dict(boxstyle="round", fc="0.7")
    arrowprops = dict(
        arrowstyle="->",
        connectionstyle="angle,angleA=0,angleB=90,rad=10")
    offset = 10

    #xycoords='figure pixels',
    xdisplay = ahora + timedelta(days=1)
    ax.annotate('Pronóstico a 4 días',
        xy=(xdisplay, ydisplay), xytext=(text_xoffset[0]*offset, -offset), textcoords='offset points',
        bbox=bbox, fontsize=18)#arrowprops=arrowprops

    xdisplay = ahora - timedelta(days=1.5)
    ax.annotate('Días pasados',
        xy=(xdisplay, ydisplay), xytext=(text_xoffset[1]*offset, -offset), textcoords='offset points',
        bbox=bbox, fontsize=18)

    ax.annotate('Fecha de emisión',
        xy=(ahora, -0.35),fontsize=15, xytext=(ahora+timedelta(days=0.3), -0.30), arrowprops=dict(facecolor='black',shrink=0.05))

    ax.annotate(' Esta previsión surge de aplicar el Modelo Matemático del Delta del PHC-SLH-INA, forzado por el caudal pronosticado del río Paraná \n de acuerdo al SIyAH-INA y por el nivel del Río de la Plata en el arco San Fernando - Nueva Palmira pronosticado por el SHN-SMN. \n Es una herramienta preliminar de pronóstico para utilizar en la emergencia hídrica, que se irá ajustando en el tiempo para \n generar información más confiable.',
                xy=(xdisplay, 0), xytext=xytext, textcoords='offset points', fontsize=11)

    if ylim:
        ax.set_ylim(ylim[0],ylim[1])
    ax.set_xlim(xmin,xmax)

    plt.grid(True, which='both', color='0.75', linestyle='-.',linewidth=0.5)
    plt.tick_params(axis='both', labelsize=16)
    plt.xlabel('Fecha', size=16)
    plt.ylabel('Nivel [m] Referido al cero local', size=20)
    plt.legend(prop={'size':18},loc=2,ncol=1 )
    # plt.title('nombre')

    date_form = DateFormatter("%H hrs \n %d-%b")
    ax.xaxis.set_major_formatter(date_form)
    ax.xaxis.set_minor_locator(mdates.HourLocator((0,6,12,18,)))

    plt.savefig(nameout, format='png')
    plt.close()

def corrigeZarate(plots=False,upload=True):
    """# Carga los datos"""

    ## Carga Simulados en Zarate
    df_Zarate_sim = getLastProno(288,{'estacion_id': '5907', 'var_id': 2})

    ## Carga Observados

    f_inicio = df_Zarate_sim.index.min()
    f_fin = df_Zarate_sim.index.max()
    Estaciones = {5907:'Zarate',}
    # Estaciones a consultar
    idDest = 5907
    idSerieOrigen = 29437
    df_Zarate_Obs = getObs(idSerieOrigen,f_inicio,f_fin)

    # Elimina saltos
    df_Zarate_Obs = eliminaSaltos(df_Zarate_Obs,0.25)
    # sns.histplot(data=df_Zarate_Obs, x="dif_F")
    # plt.show()
    # df_Zarate_Obs.set_index(df_Zarate_Obs['fecha'].dt.tz_convert(None), inplace=True)
    # del df_Zarate_Obs['fecha']

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_Zarate_sim.index = df_Zarate_sim.index + timedelta(hours=1) # - timedelta(hours=2)

    ## Union
    df_Zarate = df_Zarate_sim.join(df_Zarate_Obs, how = 'outer')
    df_Zarate['h_sim'] = df_Zarate['h_sim'].interpolate(method='linear',limit=4)
    #df_Zarate['h_sim_Mavg'] = df_Zarate['h_sim'].rolling(4, min_periods=1).mean()

    ##Plot
    if plots:
        plotObsVsSim(df_Zarate)

    """# Modelo RL"""

    train0 = df_Zarate.copy()
    train0['Error0'] = train0['h_sim'] - train0['h_obs']
    train0['dif_F1'] = train0['h_sim'].diff(periods=1).abs()
    train0['dif_F2'] = train0['h_sim'].diff(periods=2).abs()
    train0['dif_F3'] = train0['h_sim'].diff(periods=3).abs()

    train0['dif_B1'] = train0['h_sim'].diff(periods=-1).abs()
    train0['dif_B2'] = train0['h_sim'].diff(periods=-2).abs()
    train0['dif_B3'] = train0['h_sim'].diff(periods=-3).abs()

    train0['dif_F'] = train0['dif_F1'].rolling(3, min_periods=1).mean()
    train0['dif_B'] = train0['dif_B1'].rolling(3, min_periods=1).mean()

    ## Modelo
    train = train0[:].copy()
    train = train.dropna()

    var_obj = 'h_obs'
    #var_obj = 'Error0'
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2','dif_F3','dif_B3']
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2']
    covariav = ['h_sim','dif_F','dif_B']
    covariav = ['h_sim',]

    lr = linear_model.LinearRegression()
    X_train = train[covariav]
    Y_train = train[var_obj]
    lr.fit(X_train,Y_train)

    # Create the test features dataset (X_test) which will be used to make the predictions.
    X_test = train[covariav].values
    # The labels of the model
    Y_test = train[var_obj].values
    Y_predictions = lr.predict(X_test)
    train['Y_predictions'] = Y_predictions
    #train['Y_predictions'] = train['h_sim'] - train['Y_predictions'] 

    # The coefficients
    print('Coefficients B0: \n', lr.intercept_)
    print('Coefficients: \n', lr.coef_)

    # The mean squared error
    mse = mean_squared_error(Y_test, Y_predictions)
    print('Mean squared error: %.5f' % mse)
    # The coefficient of determination: 1 is perfect prediction
    coefDet = r2_score(Y_test, Y_predictions)
    print('r2_score: %.5f' % coefDet)

    train['Error_pred'] =  train['Y_predictions']  - train[var_obj]
    quant_Err = train['Error_pred'].quantile([.001,.05,.95,.999])

    ## Plot
    if plots:
        plotObsVsSimVsPred(df_Zarate,train)

    """# Predicción  en Zarate

    Predice sobre todos los datos de Zarate.  Se vuelve a calcular porque al entrenar el modelo hay datos que se eliminan por no tener un observado para comparar. Al predecir si se tiene estos datos en cuenta y se completa la serie.
    """

    df_Zarate_sim2 = df_Zarate_sim.copy()
    X_input = df_Zarate_sim2[['h_sim',]].values

    # Prediccion
    df_Zarate_sim2['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*15
    df_Zarate_sim2 = df_Zarate_sim2[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Zarate_sim2['e_pred_01'] = df_Zarate_sim2['Y_predic'] + quant_Err[0.001]
    df_Zarate_sim2['e_pred_99'] = df_Zarate_sim2['Y_predic'] + quant_Err[0.999]


    # SERIES 2 upload #

    series = [
        prono2serie(df_Zarate_sim2,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=29534)
    ]

    # PLOT FINAL
    plotFinal(df_Zarate_Obs,df_Zarate_sim2,'productos/Prono_Zarate.png',ydisplay=2,xytext=(-480,-250),ylim=(-1,2.5))
    
    """# Prediccion en ATUCHA 

    Carga los datos desde la api de Alerta
    """
    df_Atucha_sim = getLastProno(288,{'estacion_id': '151', 'var_id': 2})
    df_Atucha_Obs = getObs(151,df_Atucha_sim.index.min(),df_Atucha_sim.index.max())
    # df_Atucha_Obs.set_index(df_Atucha_Obs['fecha'].dt.tz_convert(None), inplace=True)
    # del df_Atucha_Obs['fecha']

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_Atucha_sim.index = df_Atucha_sim.index + timedelta(hours=1)

    ## Union
    # df_Atucha = df_Atucha_sim.join(df_Atucha_Obs, how = 'outer')
    # df_Atucha['h_sim'] = df_Atucha['h_sim'].interpolate(method='linear',limit=4)


    X_input = df_Atucha_sim[['h_sim',]].values

    # Prediccion
    df_Atucha_sim['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*9
    df_Atucha_sim = df_Atucha_sim[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Atucha_sim['e_pred_01'] = df_Atucha_sim['Y_predic'] + quant_Err[0.001]
    df_Atucha_sim['e_pred_99'] = df_Atucha_sim['Y_predic'] + quant_Err[0.999]

    # 2serie 

    series.append(prono2serie(df_Atucha_sim,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=3403))

    # PLOT FINAL
    plotFinal(df_Atucha_Obs,df_Atucha_sim,'productos_res/Prono_Atucha.png',3,(-420,-120),(-0.,3.5))
    plotFinal(None,df_Atucha_sim,'productos/Prono_Lima.png',3,(-420,-120),(-0.,3.5),fecha_emision=df_Atucha_Obs.index.max())

    """# Prediccion en CAMPANA ##############################

    Carga los datos desde la api de Alerta
    """

    df_Campana_sim = getLastProno(288,{'estacion_id': '41', 'var_id': 2})

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_Campana_sim.index = df_Campana_sim.index - timedelta(hours=2)

    ## Carga Observados
    f_inicio = df_Campana_sim.index.min()
    f_fin = df_Campana_sim.index.max()
    Estaciones = {41:'Campana',}
    idDest = 41
    idSerieOrigen = 41
    df_Campana_Obs = getObs(idSerieOrigen,f_inicio,f_fin)

    ###### Correccion 1 el simulado en Campana de retrasa dos horas
    df_Campana_sim.index = df_Campana_sim.index - timedelta(hours=2)

    X_input = df_Campana_sim[['h_sim',]].values

    # Prediccion
    df_Campana_sim['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*10
    df_Campana_sim = df_Campana_sim[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Campana_sim['e_pred_01'] = df_Campana_sim['Y_predic'] + quant_Err[0.001]
    df_Campana_sim['e_pred_99'] = df_Campana_sim['Y_predic'] + quant_Err[0.999]


    series.append(prono2serie(df_Campana_sim,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=3405))

    # PLOT FINAL
    plotFinal(df_Campana_Obs,df_Campana_sim,'productos/Prono_Campana.png',markersize=10,ydisplay=3.4,text_xoffset=(-2,-5),xytext=(-380,-250),ylim=(-1.,3.5),obsLine=False)
    # nameout = 'Prono_Zarate.png'    
    # plt.savefig(nameout, format='jpg')# , dpi=200, facecolor='w', edgecolor='w',bbox_inches = 'tight', pad_inches = 0

    # plt.close()

    """# Prediccion en ESCOBAR ###############################################

    Carga los datos desde la api de Alerta
    """
    df_Escobar_sim = getLastProno(288,{'estacion_id': '42', 'var_id': 2})

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_Escobar_sim.index = df_Escobar_sim.index - timedelta(hours=2)

    ## Carga Observados
    f_inicio = df_Escobar_sim.index.min()
    f_fin = df_Escobar_sim.index.max()
    Estaciones = {42:'Escobar',}
    idDest = 42
    seriesIdOrigen = 42
    df_Escobar_Obs = getObs(seriesIdOrigen,f_inicio,f_fin)

    ###### Correccion 1 el simulado en Escobar de retrasa dos horas
    df_Escobar_sim.index = df_Escobar_sim.index - timedelta(hours=2)

    X_input = df_Escobar_sim[['h_sim',]].values

    # Prediccion
    df_Escobar_sim['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*10
    df_Escobar_sim = df_Escobar_sim[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Escobar_sim['e_pred_01'] = df_Escobar_sim['Y_predic'] + quant_Err[0.001]
    df_Escobar_sim['e_pred_99'] = df_Escobar_sim['Y_predic'] + quant_Err[0.999]


    # 2series

    series.append(prono2serie(df_Escobar_sim,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=3398))

    # PLOT FINAL
    plotFinal(df_Escobar_Obs,df_Escobar_sim,'productos/Prono_Escobar.png',markersize=10,ydisplay=3.4,text_xoffset=(-2,-5),xytext=(-380,-250),ylim=(-1.,3.5),obsLine=False)
    
    ## UPLOAD PRONOSTICO
    if upload:
        uploadPronoSeries(series,cal_id=440,forecast_date=ahora,outputfile="productos/prono.json",responseOutputFile="productos/pronoresponse.json")

def corrigeRosario(plots=False,upload=True):
    ## Carga Simulados en Rosario
    df_Rosario_sim = getLastProno(288,{'estacion_id': '5893','var_id':2})

    ## Carga Observados
    f_inicio = df_Rosario_sim.index.min()
    f_fin = df_Rosario_sim.index.max()
    Estaciones = {5893:'Rosario',}
    df_Rosario_Obs = getObs(29435,f_inicio,f_fin)

    # Elimina saltos
    df_Rosario_Obs=eliminaSaltos(df_Rosario_Obs,0.25)

    ###### Correccion 1 el simulado en Rosario de retrasa dos horas
    df_Rosario_sim.index = df_Rosario_sim.index - timedelta(hours=2)

    ## Union
    df_Rosario = df_Rosario_sim.join(df_Rosario_Obs, how = 'outer')
    df_Rosario['h_sim'] = df_Rosario['h_sim'].interpolate(method='linear',limit=4)
    #df_Rosario['h_sim_Mavg'] = df_Rosario['h_sim'].rolling(4, min_periods=1).mean()

    if plots:
        plotObsVsSim(df_Rosario)

    """# Modelo RL"""

    train0 = df_Rosario.copy()
    train0['Error0'] = train0['h_sim'] - train0['h_obs']
    train0['dif_F1'] = train0['h_sim'].diff(periods=1).abs()
    train0['dif_F2'] = train0['h_sim'].diff(periods=2).abs()
    train0['dif_F3'] = train0['h_sim'].diff(periods=3).abs()

    train0['dif_B1'] = train0['h_sim'].diff(periods=-1).abs()
    train0['dif_B2'] = train0['h_sim'].diff(periods=-2).abs()
    train0['dif_B3'] = train0['h_sim'].diff(periods=-3).abs()

    train0['dif_F'] = train0['dif_F1'].rolling(3, min_periods=1).mean()
    train0['dif_B'] = train0['dif_B1'].rolling(3, min_periods=1).mean()

    
    ## Modelo
    train = train0[:].copy()
    train = train.dropna()

    var_obj = 'h_obs'
    #var_obj = 'Error0'
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2','dif_F3','dif_B3']
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2']
    covariav = ['h_sim','dif_F','dif_B']
    covariav = ['h_sim',]

    lr = linear_model.LinearRegression()
    X_train = train[covariav]
    Y_train = train[var_obj]
    lr.fit(X_train,Y_train)

    # Create the test features dataset (X_test) which will be used to make the predictions.
    X_test = train[covariav].values
    # The labels of the model
    Y_test = train[var_obj].values
    Y_predictions = lr.predict(X_test)
    train['Y_predictions'] = Y_predictions
    #train['Y_predictions'] = train['h_sim'] - train['Y_predictions'] 

    # The coefficients
    print('Coefficients B0: \n', lr.intercept_)
    print('Coefficients: \n', lr.coef_)

    # The mean squared error
    mse = mean_squared_error(Y_test, Y_predictions)
    print('Mean squared error: %.5f' % mse)
    # The coefficient of determination: 1 is perfect prediction
    coefDet = r2_score(Y_test, Y_predictions)
    print('r2_score: %.5f' % coefDet)

    train['Error_pred'] =  train['Y_predictions']  - train[var_obj]
    quant_Err = train['Error_pred'].quantile([.001,.05,.95,.999])

    if plots:
        plotObsVsSimVsPred(df_Rosario,train)
    
    """# Predicción  en Rosario

    Predice sobre todos los datos de Rosario.  Se vuelve a calcular porque al entrenar el modelo hay datos que se eliminan por no tener un observado para comparar. Al predecir si se tiene estos datos en cuenta y se completa la serie.
    """

    df_Rosario_sim2 = df_Rosario_sim.copy()
    X_input = df_Rosario_sim2[['h_sim',]].values

    # Prediccion
    df_Rosario_sim2['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*15
    df_Rosario_sim2 = df_Rosario_sim2[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Rosario_sim2['e_pred_01'] = df_Rosario_sim2['Y_predic'] + quant_Err[0.001]
    df_Rosario_sim2['e_pred_99'] = df_Rosario_sim2['Y_predic'] + quant_Err[0.999]

    # 2 series

    series =  [
        prono2serie(df_Rosario_sim2,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=29542)
    ]

    # PLOT FINAL
    plotFinal(df_Rosario_Obs,df_Rosario_sim2,'productos/Prono_Rosario.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=(-1,1))
   
    """# Prediccion en Rosario_vPNAobs"""

    ## Carga Observados

    f_inicio = df_Rosario_sim.index.min()
    f_fin = df_Rosario_sim.index.max()
    Estaciones = {34:'Rosario',}
    idDest = 34
    df_RosarioPNA_Obs = getObs(idDest,f_inicio,f_fin)

    # PLOT FINAL
    plotFinal(df_RosarioPNA_Obs,df_Rosario_sim2,'productos/Prono_RosarioPNA.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=(-1.,2),obs_label='Nivel Observado PNA',extraObs=df_Rosario_Obs,extraObsLabel="Nivel Observado BDHI",fecha_emision=df_Rosario_Obs.index.max(),obsLine=False)

    """# Prediccion en Timbues"""
    df_Timbues_sim = getLastProno(288,{'estacion_id': '1770','var_id':2})

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_Timbues_sim.index = df_Timbues_sim.index - timedelta(hours=2)

    X_input = df_Timbues_sim[['h_sim',]].values

    # Prediccion
    df_Timbues_sim['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*10
    df_Timbues_sim = df_Timbues_sim[-horas_plot:]
    # df_simulado['e_pred_05'] = df_simulado['Y_predic'] + quant_Err[0.05]
    # df_simulado['e_pred_95'] = df_simulado['Y_predic'] + quant_Err[0.95]
    df_Timbues_sim['e_pred_01'] = df_Timbues_sim['Y_predic'] + quant_Err[0.001]
    df_Timbues_sim['e_pred_99'] = df_Timbues_sim['Y_predic'] + quant_Err[0.999]

    # 2 series
    series.append(prono2serie(df_Timbues_sim,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_99':'p99'},series_id=3389))

    # PLOT FINAL
    plotFinal(None,df_Timbues_sim,'productos/Prono_Timbues.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=None)
    
    ## UPLOAD PRONOSTICO
    if upload:
        uploadPronoSeries(series,cal_id=441,forecast_date=df_Rosario_Obs.index.max(),outputfile="productos/prono.json",responseOutputFile="productos/pronoresponse.json")

def corrigeVCons(plots=False,upload=True):
        ## Carga Simulados en VConstitucion
    df_VConstitucion_sim = getLastProno(288,{'estacion_id': '5905','var_id':2})

    ## Carga Observados
    f_inicio = df_VConstitucion_sim.index.min()
    f_fin = df_VConstitucion_sim.index.max()
    df_VConstitucion_Obs = getObs(29436,f_inicio,f_fin)

    # Elimina saltos
    df_VConstitucion_Obs = eliminaSaltos(df_VConstitucion_Obs,0.25)

    ###### Correccion 1 el simulado en VConstitucion de retrasa dos horas
    df_VConstitucion_sim.index = df_VConstitucion_sim.index - timedelta(hours=2)

    ## Union
    df_VConstitucion = df_VConstitucion_sim.join(df_VConstitucion_Obs, how = 'outer')
    df_VConstitucion['h_sim'] = df_VConstitucion['h_sim'].interpolate(method='linear',limit=4)
    #df_VConstitucion['h_sim_Mavg'] = df_VConstitucion['h_sim'].rolling(4, min_periods=1).mean()

    if plots:
        plotObsVsSim(df_VConstitucion)

    """# Modelo RL"""

    train0 = df_VConstitucion.copy()
    train0['Error0'] = train0['h_sim'] - train0['h_obs']
    train0['dif_F1'] = train0['h_sim'].diff(periods=1).abs()
    train0['dif_F2'] = train0['h_sim'].diff(periods=2).abs()
    train0['dif_F3'] = train0['h_sim'].diff(periods=3).abs()

    train0['dif_B1'] = train0['h_sim'].diff(periods=-1).abs()
    train0['dif_B2'] = train0['h_sim'].diff(periods=-2).abs()
    train0['dif_B3'] = train0['h_sim'].diff(periods=-3).abs()

    train0['dif_F'] = train0['dif_F1'].rolling(3, min_periods=1).mean()
    train0['dif_B'] = train0['dif_B1'].rolling(3, min_periods=1).mean()

    ## Modelo
    train = train0[:].copy()
    train = train.dropna()

    var_obj = 'h_obs'
    #var_obj = 'Error0'
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2','dif_F3','dif_B3']
    covariav = ['h_sim','dif_F1','dif_B1','dif_F2','dif_B2']
    covariav = ['h_sim','dif_F','dif_B']
    covariav = ['h_sim',]

    lr = linear_model.LinearRegression()
    X_train = train[covariav]
    Y_train = train[var_obj]
    lr.fit(X_train,Y_train)

    # Create the test features dataset (X_test) which will be used to make the predictions.
    X_test = train[covariav].values
    # The labels of the model
    Y_test = train[var_obj].values
    Y_predictions = lr.predict(X_test)
    train['Y_predictions'] = Y_predictions
    #train['Y_predictions'] = train['h_sim'] - train['Y_predictions'] 

    # The coefficients
    print('Coefficients B0: \n', lr.intercept_)
    print('Coefficients: \n', lr.coef_)

    # The mean squared error
    mse = mean_squared_error(Y_test, Y_predictions)
    print('Mean squared error: %.5f' % mse)
    # The coefficient of determination: 1 is perfect prediction
    coefDet = r2_score(Y_test, Y_predictions)
    print('r2_score: %.5f' % coefDet)

    train['Error_pred'] =  train['Y_predictions']  - train[var_obj]
    quant_Err = train['Error_pred'].quantile([.001,.05,.95,.999])

    if plots:
        plotObsVsSimVsPred(df_VConstitucion,train)

    """# Predicción  en VConstitucion

    Predice sobre todos los datos de VConstitucion.  Se vuelve a calcular porque al entrenar el modelo hay datos que se eliminan por no tener un observado para comparar. Al predecir si se tiene estos datos en cuenta y se completa la serie.
    """

    df_VConstitucion_sim2 = df_VConstitucion_sim.copy()
    X_input = df_VConstitucion_sim2[['h_sim',]].values

    # Prediccion
    df_VConstitucion_sim2['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*15
    df_VConstitucion_sim2 = df_VConstitucion_sim2[-horas_plot:]
    df_VConstitucion_sim2['e_pred_05'] = df_VConstitucion_sim2['Y_predic'] + quant_Err[0.05]
    df_VConstitucion_sim2['e_pred_95'] = df_VConstitucion_sim2['Y_predic'] + quant_Err[0.95]
    df_VConstitucion_sim2['e_pred_01'] = df_VConstitucion_sim2['Y_predic'] + quant_Err[0.001]
    df_VConstitucion_sim2['e_pred_99'] = df_VConstitucion_sim2['Y_predic'] + quant_Err[0.999]

    series = [
        prono2serie(df_VConstitucion_sim2,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_05':'p05','e_pred_95':'e95','e_pred_99':'p99'},series_id=29538)
    ]

    # PLOT FINAL
    plotFinal(df_VConstitucion_Obs,df_VConstitucion_sim2,'productos/Prono_VConstitucion.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=(-0.5,1),bandaDeError=('e_pred_05','e_pred_95'))

    """# Prediccion en VConstitucion_vPNAobs"""

    ## Carga Observados
    f_inicio = df_VConstitucion_sim.index.min()
    f_fin = df_VConstitucion_sim.index.max()
    Estaciones = {35:'VConstitucion',}
    df_VConstitucionPNA_Obs = getObs(35,f_inicio,f_fin)

    # PLOT FINAL
    plotFinal(df_VConstitucionPNA_Obs,df_VConstitucion_sim2,'productos/Prono_VConstitucionPNA.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=(-1.,2),bandaDeError=('e_pred_05','e_pred_95'),extraObs=df_VConstitucion_Obs,extraObsLabel='Nivel Observado BDHI',obs_label='Nivel Observado PNA',fecha_emision=df_VConstitucion_Obs.index.max(),obsLine=False)

    """# Prediccion en SanNicolas"""

    df_SanNicolas_sim = getLastProno(288,{'estacion_id': '36','var_id':2})

    ###### Correccion 1 el simulado en zarate de retrasa dos horas
    df_SanNicolas_sim.index = df_SanNicolas_sim.index - timedelta(hours=2)

    ## Carga Observados
    f_inicio = df_SanNicolas_sim.index.min()
    f_fin = df_SanNicolas_sim.index.max()
    df_SanNicolas_Obs = getObs(36,f_inicio,f_fin)

    X_input = df_SanNicolas_sim[['h_sim',]].values

    # Prediccion
    df_SanNicolas_sim['Y_predic'] = lr.predict(X_input)

    horas_plot = 24*10
    df_SanNicolas_sim = df_SanNicolas_sim[-horas_plot:]
    df_SanNicolas_sim['e_pred_05'] = df_SanNicolas_sim['Y_predic'] + quant_Err[0.05]
    df_SanNicolas_sim['e_pred_95'] = df_SanNicolas_sim['Y_predic'] + quant_Err[0.95]
    df_SanNicolas_sim['e_pred_01'] = df_SanNicolas_sim['Y_predic'] + quant_Err[0.001]
    df_SanNicolas_sim['e_pred_99'] = df_SanNicolas_sim['Y_predic'] + quant_Err[0.999]

    # 2 series
    series.append(prono2serie(df_SanNicolas_sim,main_colname="Y_predic",members={'e_pred_01':'p01','e_pred_05':'p05','e_pred_95':'e95','e_pred_99':'p99'},series_id=3414))
    
    # PLOT FINAL
    plotFinal(df_SanNicolas_Obs,df_SanNicolas_sim,'productos/Prono_SanNicolas.png',ydisplay=3.4,text_xoffset=(0.5,0.5),ylim=(-1.,2),bandaDeError=('e_pred_05','e_pred_95'),markersize=10,obsLine=False)

    ## UPLOAD PRONOSTICO
    if upload:
        uploadPronoSeries(series,cal_id=442,forecast_date=df_VConstitucion_Obs.index.max(),outputfile="productos/prono.json",responseOutputFile="productos/pronoresponse.json")


### RUN ###

corrigeZarate(plots=False,upload=False)
#corrigeRosario(plots=False,upload=False)
#corrigeVCons(plots=False,upload=False)